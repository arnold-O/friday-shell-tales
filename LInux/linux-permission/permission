**Understanding ownership**

Every file have three ( 3 ) entities that can be used to set the permissions/ownership, these entities are "user", "group" and "other"

The checks for permissions for file/directory follows the other they have been listed above ( user, group and other). 
If a usr wants to acces a file, Linux first checks if the user is the owner taht checking the user entity, then if not linux moves
to the group if the user is part of the group and neither user or group checks out it goes to the other entity to grant/ deny the 
permission.

These permission enttities are represented as 
 r == Read
 w == write
 x == Execute

 We have a hyphen or dash to represent ths for each file for:

 user - - -  the three hyphen to be filled with R W x
 group - - - the same with r w x
 other - - -  same as above with r w x

add a file here 

The id <username> command, from our user-creation series, displays a user’s UID, GID, and group memberships.

By default, a user’s primary group is the group assigned when the user is created. When a user creates a file or directory, that primary group is automatically set as the group owner of the newly created file or directory.

For example, when a user named testuser creates a file or directory, testuser becomes both the owner and the group owner of that file by default.

— show file screenshot here —

This behavior is not fixed and can be changed manually, as we will explore later in this series.as this series progresses.


Use of chown

chown stands for change owner/ownership. This command is used to change the owner of a file or directory, and it can also be used to change the group ownership at the same time. to.

For example:
chown <testuser1> <file/directoy>

The command above changes the owner of the specified file or directory to testuser1.

As mentioned earlier, chown can modify both the owner and the group simultaneously by using a colon (:) as a separator, as shown below:

chown testuser:<groupname>  <file/directory>

This command changes the ownership of a file or directory to the specified user (testuser) and group (groupname). Adding the `-R` flag makes the command recursive, ensuring that all files and subdirectories within the specified directory inherit the same ownership.

While `chown` is used to change both the owner and group of a file, there is a dedicated command for changing only the group ownership: `chgrp`. To change the group ownership alone, the command becomes:

```bash
chgrp <groupname> <file/directory>
```

If you want to change both the owner and group at the same time, you can use `chown` with the following syntax:

```bash
chown <owner>:<groupname> <file/directory>
```


The permission table and the meaning for files and directories:

| Action   | Directory       | File       | Numerical Value |
|----------|-----------------|------------|-----------------|
| Read     | List contents   | Open file  | 4               |
| Write    | Create/Delete   | Modify     | 2               |
| Execute  | Enter directory | Run file   | 1               |


The Read permission is quite tricky as user with read on a directory can list the content on the directory bur can only read the content on that directory if the files or content on the directory permssion is correct, that is to say the read on a directory only list the content and reasding its content is purely the permissions on the content.



**Permission Using Numeric Mode**

As shown in the table above, numeric values are used to set permissions on a file. These values range from 0 to 7, representing combinations of read (4), write (2), and execute (1) permissions. The sum of these values determines the permission level.

For example:
- `4` (read)
- `2` (write)
- `1` (execute)

If a number other than 4, 2, or 1 is used, it is broken down into these components. For instance, `7` is the sum of `4 + 2 + 1`, meaning read, write, and execute permissions are granted.

**Numeric Mode Usage**

The numeric mode assigns permissions to three entities: user, group, and others. For example:

```bash
chmod 767 <filename>
```

Here:
- `7` (user) = `4 + 2 + 1` → `rwx` (read, write, execute)
- `6` (group) = `4 + 2` → `rw-` (read, write)
- `7` (others) = `4 + 2 + 1` → `rwx` (read, write, execute)


Another example : if we have  chmod 325 <filename>

In this case:
user == 3  this further translate to 2 + 1 = 3; hence for this file user has -wx
group == 2 this further translate to 2  = 6; hence for this file group has -w-
other == 5  this further translate to 4 + 1 = 5; hence for this file user has r-x

These scenerios will help you understand the numeric mode usage if the additional and number break is not entirely clear

Number           Permission Type              symbol
0                  no permission               ---
1                  Execute                     --x
2                  write                       -w-
3                  Execute + Write             -wx
4                  Read                        r--
5                  Read + Execute              r-x
6                  Read + Write                rw-
7                  Read + write + Execute      rwx


Access Control Lists (ACL)

Access Control Lists (ACLs) provide an additional layer of permissions on top of the standard Linux file and directory permissions.

The commands used to manage ACL permissions are:

setfacl — used to assign or modify ACL permissions

getfacl — used to view the ACL permissions currently applied to a file or directory

setfacl allows you to configure this extra layer of access control, while getfacl helps you inspect the existing ACL settings.


Setting Up ACLs

I. Add permissions for a specific user

setfacl -m u:username:rwx /path/to/file


This command grants read, write, and execute permissions to the specified user on the file or directory.

II. Add permissions for a specific group

setfacl -m g:groupname:rwx /path/to/file


This command assigns read, write, and execute permissions to the specified group.

To apply the same permissions recursively to all subdirectories and files, use the -R flag:

setfacl -Rm g:groupname:rwx /path/to/file


III. Remove ACL permissions for a specific user

setfacl -x u:username /path/to/file


This removes the ACL entry for the specified user.

IV. Remove all ACL entries

setfacl -b /path/to/file


This clears all ACL permissions from the file or directory.


When you assign an ACL to a file or directory, a plus sign (+) is added at the end of the permission bits when viewed with ls -l. This indicates that extended ACLs are applied.

When you run getfacl on a file—for example, file.txt—the output may look like this:

# file: file.txt
# owner: alice
# group: staff
user::rw-
user:bob:r--
group::r--
mask::r--
other::---


Example: Granting permissions to a specific user using ACL

setfacl -m u:bob:rw file.txt


-m → modifies the ACL

u:bob:rw → grants Bob read and write permissions

file.txt → the target file

i. Grant permissions to a specific group

setfacl -m g:devs:r file.txt


g:devs:r → grants read permission to all members of the devs group

ii. Remove ACL permissions for a specific user

setfacl -x u:bob file.txt


This command removes the ACL entry for user bob.



Using the chmod for permission  ( To know more about chmod  run man chmod to know more )

Examples of using u:g:o:a to change permissions

1. Give the owner full access:
chmod u+rwx <path/to/file>

2. Give the group read and write access:
chmod g+rw <path/to/file>

3. Give others only read access:
chmod o+r file.txt

4. Give everyone execute permission:
chmod a+x script.sh

5. Remove write permission from everyone:
chmod a-w file.txt

6. Apply all permission entities in one goal:
chmod u+rwx,g+rx,o-rwx backup.sh

umask (user file-creation mode mask)

UMASK

umask defines which permissions are removed when files or directories are created:

Files start from 666

Directories start from 777

Final permissions = Base − umask

Examples of `umask`:

- `0002`: Files get `u=rw-, g=rw-, o=r--`.
- `0022`: Files get `u=rw-, g=r--, o=r--`.

